; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30138.0 

	TITLE	c:\jna_repro\src\native\sse_repro.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_calloc:PROC
EXTRN	@__security_check_cookie@4:PROC
$SG4294967291 DB 0aH, 'Pointers are %p, %p, %p, %p, %p, %p, %p, %p', 0aH, 00H
CONST	ENDS
PUBLIC	_ReadSSERegisters@0
PUBLIC	_ShuffleSSERegisters@0
PUBLIC	?ShuffleSSERegisters_vector@@YQXT__m128@@0000000@Z ; ShuffleSSERegisters_vector
PUBLIC	_printf
PUBLIC	__vfprintf_l
PUBLIC	___local_stdio_printf_options
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	51		 push	 ecx
  0001c	8b 10		 mov	 edx, DWORD PTR [eax]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 646  :     }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0000f	51		 push	 ecx
  00010	6a 00		 push	 0
  00012	8b 55 08	 mov	 edx, DWORD PTR __Format$[ebp]
  00015	52		 push	 edx
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001d	83 c4 04	 add	 esp, 4
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 __vfprintf_l
  00026	83 c4 10	 add	 esp, 16			; 00000010H
  00029	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

  00033	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 963  :     }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\jna_repro\src\native\sse_repro.cpp
_TEXT	SEGMENT
_xmm_write_register_0$ = -144				; size = 16
_xmm_write_register_1$ = -128				; size = 16
_xmm_write_register_2$ = -112				; size = 16
_xmm_write_register_3$ = -96				; size = 16
_xmm_write_register_4$ = -80				; size = 16
_xmm_write_register_5$ = -64				; size = 16
$T1 = -48						; size = 16
$T2 = -32						; size = 16
_xmm_write_register_6$ = -8				; size = 4
_xmm_write_register_7$ = -4				; size = 4
?ShuffleSSERegisters_vector@@YQXT__m128@@0000000@Z PROC	; ShuffleSSERegisters_vector
; _xmm_write_register_0$ = xmm0
; _xmm_write_register_1$ = xmm1
; _xmm_write_register_2$ = xmm2
; _xmm_write_register_3$ = xmm3
; _xmm_write_register_4$ = xmm4
; _xmm_write_register_5$ = xmm5
; _xmm_write_register_6$ = ecx
; _xmm_write_register_7$ = edx

; 13   : 	__m128 xmm_write_register_7) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0001c	89 55 fc	 mov	 DWORD PTR _xmm_write_register_7$[ebp], edx
  0001f	89 4d f8	 mov	 DWORD PTR _xmm_write_register_6$[ebp], ecx
  00022	0f 29 6d c0	 movaps	 XMMWORD PTR _xmm_write_register_5$[ebp], xmm5
  00026	0f 29 65 b0	 movaps	 XMMWORD PTR _xmm_write_register_4$[ebp], xmm4
  0002a	0f 29 5d a0	 movaps	 XMMWORD PTR _xmm_write_register_3$[ebp], xmm3
  0002e	0f 29 55 90	 movaps	 XMMWORD PTR _xmm_write_register_2$[ebp], xmm2
  00032	0f 29 4d 80	 movaps	 XMMWORD PTR _xmm_write_register_1$[ebp], xmm1
  00036	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _xmm_write_register_0$[ebp], xmm0
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _xmm_write_register_6$[ebp]
  00040	8d 4d e0	 lea	 ecx, DWORD PTR $T2[ebp]
  00043	8b 10		 mov	 edx, DWORD PTR [eax]
  00045	89 11		 mov	 DWORD PTR [ecx], edx
  00047	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0004d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00050	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00053	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00056	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00059	8d 4d e0	 lea	 ecx, DWORD PTR $T2[ebp]
  0005c	89 4d f8	 mov	 DWORD PTR _xmm_write_register_6$[ebp], ecx
  0005f	8b 55 fc	 mov	 edx, DWORD PTR _xmm_write_register_7$[ebp]
  00062	8d 45 d0	 lea	 eax, DWORD PTR $T1[ebp]
  00065	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00067	89 08		 mov	 DWORD PTR [eax], ecx
  00069	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0006c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0006f	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00075	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00078	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0007b	8d 45 d0	 lea	 eax, DWORD PTR $T1[ebp]
  0007e	89 45 fc	 mov	 DWORD PTR _xmm_write_register_7$[ebp], eax

; 14   : 	// Use the registers for printf so the compiler doesn't optimize everything away
; 15   : 	printf("\nPointers are %p, %p, %p, %p, %p, %p, %p, %p\n",

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _xmm_write_register_7$[ebp]
  00084	51		 push	 ecx
  00085	8b 55 f8	 mov	 edx, DWORD PTR _xmm_write_register_6$[ebp]
  00088	52		 push	 edx
  00089	8d 45 c0	 lea	 eax, DWORD PTR _xmm_write_register_5$[ebp]
  0008c	50		 push	 eax
  0008d	8d 4d b0	 lea	 ecx, DWORD PTR _xmm_write_register_4$[ebp]
  00090	51		 push	 ecx
  00091	8d 55 a0	 lea	 edx, DWORD PTR _xmm_write_register_3$[ebp]
  00094	52		 push	 edx
  00095	8d 45 90	 lea	 eax, DWORD PTR _xmm_write_register_2$[ebp]
  00098	50		 push	 eax
  00099	8d 4d 80	 lea	 ecx, DWORD PTR _xmm_write_register_1$[ebp]
  0009c	51		 push	 ecx
  0009d	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _xmm_write_register_0$[ebp]
  000a3	52		 push	 edx
  000a4	68 00 00 00 00	 push	 OFFSET $SG4294967291
  000a9	e8 00 00 00 00	 call	 _printf
  000ae	83 c4 24	 add	 esp, 36			; 00000024H

; 16   : 		(&xmm_write_register_0),
; 17   : 		(&xmm_write_register_1),
; 18   : 		(&xmm_write_register_2),
; 19   : 		(&xmm_write_register_3),
; 20   : 		(&xmm_write_register_4),
; 21   : 		(&xmm_write_register_5),
; 22   : 		(&xmm_write_register_6),
; 23   : 		(&xmm_write_register_7)
; 24   : 	);
; 25   : }

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	8b e3		 mov	 esp, ebx
  000b6	5b		 pop	 ebx
  000b7	c3		 ret	 0
?ShuffleSSERegisters_vector@@YQXT__m128@@0000000@Z ENDP	; ShuffleSSERegisters_vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\jna_repro\src\native\sse_repro.cpp
_TEXT	SEGMENT
$T1 = -304						; size = 16
$T2 = -288						; size = 16
_xmm_write_register_0$ = -272				; size = 16
_xmm_write_register_1$ = -256				; size = 16
_xmm_write_register_2$ = -240				; size = 16
_xmm_write_register_3$ = -224				; size = 16
_xmm_write_register_4$ = -208				; size = 16
_xmm_write_register_5$ = -192				; size = 16
_xmm_write_register_6$ = -176				; size = 16
_xmm_write_register_7$ = -160				; size = 16
$T3 = -144						; size = 16
$T4 = -128						; size = 16
$T5 = -112						; size = 16
$T6 = -96						; size = 16
$T7 = -80						; size = 16
$T8 = -64						; size = 16
$T9 = -48						; size = 16
$T10 = -32						; size = 16
_writebuffer$ = -12					; size = 4
_i$11 = -8						; size = 4
_fake$ = -4						; size = 4
_ShuffleSSERegisters@0 PROC

; 27   : extern "C" __declspec(dllexport) float* __stdcall ShuffleSSERegisters() {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H

; 28   : 	// __m128 holds an SSE compatible value in a struct
; 29   : 	__m128 xmm_write_register_0;
; 30   : 	__m128 xmm_write_register_1;
; 31   : 	__m128 xmm_write_register_2;
; 32   : 	__m128 xmm_write_register_3;
; 33   : 	__m128 xmm_write_register_4;
; 34   : 	__m128 xmm_write_register_5;
; 35   : 	__m128 xmm_write_register_6;
; 36   : 	__m128 xmm_write_register_7;
; 37   : 
; 38   : 	// Fill an buffer with looping bytes 00..FF
; 39   : 	byte* writebuffer = (byte*)calloc(4 * 8, 32);

  0001c	6a 20		 push	 32			; 00000020H
  0001e	6a 20		 push	 32			; 00000020H
  00020	e8 00 00 00 00	 call	 _calloc
  00025	83 c4 08	 add	 esp, 8
  00028	89 45 f4	 mov	 DWORD PTR _writebuffer$[ebp], eax

; 40   : 	for (int i = 0; i < 4 * 8 * 32; i++)

  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$11[ebp], 0
  00032	eb 09		 jmp	 SHORT $LN4@ShuffleSSE
$LN2@ShuffleSSE:
  00034	8b 45 f8	 mov	 eax, DWORD PTR _i$11[ebp]
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 f8	 mov	 DWORD PTR _i$11[ebp], eax
$LN4@ShuffleSSE:
  0003d	81 7d f8 00 04
	00 00		 cmp	 DWORD PTR _i$11[ebp], 1024 ; 00000400H
  00044	7d 0d		 jge	 SHORT $LN3@ShuffleSSE

; 41   : 		writebuffer[i] = i;

  00046	8b 4d f4	 mov	 ecx, DWORD PTR _writebuffer$[ebp]
  00049	03 4d f8	 add	 ecx, DWORD PTR _i$11[ebp]
  0004c	8a 55 f8	 mov	 dl, BYTE PTR _i$11[ebp]
  0004f	88 11		 mov	 BYTE PTR [ecx], dl
  00051	eb e1		 jmp	 SHORT $LN2@ShuffleSSE
$LN3@ShuffleSSE:

; 42   : 
; 43   : 	// Use those bytes as floats for test data
; 44   : 	float* fake = (float*)writebuffer;

  00053	8b 45 f4	 mov	 eax, DWORD PTR _writebuffer$[ebp]
  00056	89 45 fc	 mov	 DWORD PTR _fake$[ebp], eax

; 45   : 
; 46   : 	// Load the generated random data into __m128 placeholders
; 47   : 	xmm_write_register_0 = _mm_loadu_ps(fake + (4 * 0));

  00059	8b 4d fc	 mov	 ecx, DWORD PTR _fake$[ebp]
  0005c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0005f	0f 29 45 e0	 movaps	 XMMWORD PTR $T10[ebp], xmm0
  00063	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR $T10[ebp]
  00067	0f 29 85 f0 fe
	ff ff		 movaps	 XMMWORD PTR _xmm_write_register_0$[ebp], xmm0

; 48   : 	xmm_write_register_1 = _mm_loadu_ps(fake + (4 * 1));

  0006e	8b 55 fc	 mov	 edx, DWORD PTR _fake$[ebp]
  00071	83 c2 10	 add	 edx, 16			; 00000010H
  00074	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00077	0f 29 45 d0	 movaps	 XMMWORD PTR $T9[ebp], xmm0
  0007b	0f 28 45 d0	 movaps	 xmm0, XMMWORD PTR $T9[ebp]
  0007f	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR _xmm_write_register_1$[ebp], xmm0

; 49   : 	xmm_write_register_2 = _mm_loadu_ps(fake + (4 * 2));

  00086	8b 45 fc	 mov	 eax, DWORD PTR _fake$[ebp]
  00089	83 c0 20	 add	 eax, 32			; 00000020H
  0008c	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0008f	0f 29 45 c0	 movaps	 XMMWORD PTR $T8[ebp], xmm0
  00093	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T8[ebp]
  00097	0f 29 85 10 ff
	ff ff		 movaps	 XMMWORD PTR _xmm_write_register_2$[ebp], xmm0

; 50   : 	xmm_write_register_3 = _mm_loadu_ps(fake + (4 * 3));

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _fake$[ebp]
  000a1	83 c1 30	 add	 ecx, 48			; 00000030H
  000a4	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000a7	0f 29 45 b0	 movaps	 XMMWORD PTR $T7[ebp], xmm0
  000ab	0f 28 45 b0	 movaps	 xmm0, XMMWORD PTR $T7[ebp]
  000af	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR _xmm_write_register_3$[ebp], xmm0

; 51   : 	xmm_write_register_4 = _mm_loadu_ps(fake + (4 * 4));

  000b6	8b 55 fc	 mov	 edx, DWORD PTR _fake$[ebp]
  000b9	83 c2 40	 add	 edx, 64			; 00000040H
  000bc	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  000bf	0f 29 45 a0	 movaps	 XMMWORD PTR $T6[ebp], xmm0
  000c3	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR $T6[ebp]
  000c7	0f 29 85 30 ff
	ff ff		 movaps	 XMMWORD PTR _xmm_write_register_4$[ebp], xmm0

; 52   : 	xmm_write_register_5 = _mm_loadu_ps(fake + (4 * 5));

  000ce	8b 45 fc	 mov	 eax, DWORD PTR _fake$[ebp]
  000d1	83 c0 50	 add	 eax, 80			; 00000050H
  000d4	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000d7	0f 29 45 90	 movaps	 XMMWORD PTR $T5[ebp], xmm0
  000db	0f 28 45 90	 movaps	 xmm0, XMMWORD PTR $T5[ebp]
  000df	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _xmm_write_register_5$[ebp], xmm0

; 53   : 	xmm_write_register_6 = _mm_loadu_ps(fake + (4 * 6));

  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _fake$[ebp]
  000e9	83 c1 60	 add	 ecx, 96			; 00000060H
  000ec	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  000ef	0f 29 45 80	 movaps	 XMMWORD PTR $T4[ebp], xmm0
  000f3	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T4[ebp]
  000f7	0f 29 85 50 ff
	ff ff		 movaps	 XMMWORD PTR _xmm_write_register_6$[ebp], xmm0

; 54   : 	xmm_write_register_7 = _mm_loadu_ps(fake + (4 * 7));

  000fe	8b 55 fc	 mov	 edx, DWORD PTR _fake$[ebp]
  00101	83 c2 70	 add	 edx, 112		; 00000070H
  00104	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00107	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR $T3[ebp], xmm0
  0010e	0f 28 85 70 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR $T3[ebp]
  00115	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _xmm_write_register_7$[ebp], xmm0

; 55   : 
; 56   : 	// Pass the placeholders to our __vectorcall function
; 57   : 	// VC is going to put them in registers as per __vectorcall
; 58   : 	// specification.
; 59   : 	ShuffleSSERegisters_vector(

  0011c	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xmm_write_register_7$[ebp]
  00123	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR $T2[ebp], xmm0
  0012a	0f 28 85 50 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _xmm_write_register_6$[ebp]
  00131	0f 29 85 d0 fe
	ff ff		 movaps	 XMMWORD PTR $T1[ebp], xmm0
  00138	0f 28 ad 40 ff
	ff ff		 movaps	 xmm5, XMMWORD PTR _xmm_write_register_5$[ebp]
  0013f	0f 28 a5 30 ff
	ff ff		 movaps	 xmm4, XMMWORD PTR _xmm_write_register_4$[ebp]
  00146	0f 28 9d 20 ff
	ff ff		 movaps	 xmm3, XMMWORD PTR _xmm_write_register_3$[ebp]
  0014d	0f 28 95 10 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _xmm_write_register_2$[ebp]
  00154	0f 28 8d 00 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _xmm_write_register_1$[ebp]
  0015b	0f 28 85 f0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR _xmm_write_register_0$[ebp]
  00162	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  00168	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0016e	e8 00 00 00 00	 call	 ?ShuffleSSERegisters_vector@@YQXT__m128@@0000000@Z ; ShuffleSSERegisters_vector

; 60   : 		xmm_write_register_0,
; 61   : 		xmm_write_register_1,
; 62   : 		xmm_write_register_2,
; 63   : 		xmm_write_register_3,
; 64   : 		xmm_write_register_4,
; 65   : 		xmm_write_register_5,
; 66   : 		xmm_write_register_6,
; 67   : 		xmm_write_register_7
; 68   : 		);
; 69   : 
; 70   : 	// Return our test data to Java for comparison
; 71   : 	return fake;

  00173	8b 45 fc	 mov	 eax, DWORD PTR _fake$[ebp]

; 72   : }

  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	8b e3		 mov	 esp, ebx
  0017b	5b		 pop	 ebx
  0017c	c3		 ret	 0
_ShuffleSSERegisters@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\jna_repro\src\native\sse_repro.cpp
_TEXT	SEGMENT
_xmm_read_register_7$ = -144				; size = 16
_xmm_read_register_6$ = -128				; size = 16
_xmm_read_register_5$ = -112				; size = 16
_xmm_read_register_4$ = -96				; size = 16
_xmm_read_register_3$ = -80				; size = 16
_xmm_read_register_2$ = -64				; size = 16
_xmm_read_register_1$ = -48				; size = 16
_xmm_read_register_0$ = -32				; size = 16
$T1 = -8						; size = 4
_readbuffer$ = -4					; size = 4
_ReadSSERegisters@0 PROC

; 74   : extern "C" __declspec(dllexport) float* __stdcall ReadSSERegisters() {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H

; 75   : 	// Structs we read the data into
; 76   : 	__m128 xmm_read_register_0;
; 77   : 	__m128 xmm_read_register_1;
; 78   : 	__m128 xmm_read_register_2;
; 79   : 	__m128 xmm_read_register_3;
; 80   : 	__m128 xmm_read_register_4;
; 81   : 	__m128 xmm_read_register_5;
; 82   : 	__m128 xmm_read_register_6;
; 83   : 	__m128 xmm_read_register_7;
; 84   : 
; 85   : 	// Move the current register values to the placeholder variables
; 86   : 	__asm {
; 87   : 		MOVDQU xmm_read_register_0, xmm0

  0001c	f3 0f 7f 45 e0	 movdqu	 XMMWORD PTR _xmm_read_register_0$[ebp], xmm0

; 88   : 		MOVDQU xmm_read_register_1, xmm1

  00021	f3 0f 7f 4d d0	 movdqu	 XMMWORD PTR _xmm_read_register_1$[ebp], xmm1

; 89   : 		MOVDQU xmm_read_register_2, xmm2

  00026	f3 0f 7f 55 c0	 movdqu	 XMMWORD PTR _xmm_read_register_2$[ebp], xmm2

; 90   : 		MOVDQU xmm_read_register_3, xmm3

  0002b	f3 0f 7f 5d b0	 movdqu	 XMMWORD PTR _xmm_read_register_3$[ebp], xmm3

; 91   : 		MOVDQU xmm_read_register_4, xmm4

  00030	f3 0f 7f 65 a0	 movdqu	 XMMWORD PTR _xmm_read_register_4$[ebp], xmm4

; 92   : 		MOVDQU xmm_read_register_5, xmm5

  00035	f3 0f 7f 6d 90	 movdqu	 XMMWORD PTR _xmm_read_register_5$[ebp], xmm5

; 93   : 		MOVDQU xmm_read_register_6, xmm6

  0003a	f3 0f 7f 75 80	 movdqu	 XMMWORD PTR _xmm_read_register_6$[ebp], xmm6

; 94   : 		MOVDQU xmm_read_register_7, xmm7

  0003f	f3 0f 7f bd 70
	ff ff ff	 movdqu	 XMMWORD PTR _xmm_read_register_7$[ebp], xmm7

; 95   : 	}
; 96   : 
; 97   : 	// Read the placeholders into a bunch of floats
; 98   : 	float* readbuffer = new float[4 * 8];

  00047	68 80 00 00 00	 push	 128			; 00000080H
  0004c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00051	83 c4 04	 add	 esp, 4
  00054	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00057	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0005a	89 45 fc	 mov	 DWORD PTR _readbuffer$[ebp], eax

; 99   : 	_mm_storeu_ps(readbuffer + (4 * 0), xmm_read_register_0);

  0005d	0f 10 45 e0	 movups	 xmm0, XMMWORD PTR _xmm_read_register_0$[ebp]
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _readbuffer$[ebp]
  00064	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 100  : 	_mm_storeu_ps(readbuffer + (4 * 1), xmm_read_register_1);

  00067	0f 10 45 d0	 movups	 xmm0, XMMWORD PTR _xmm_read_register_1$[ebp]
  0006b	8b 55 fc	 mov	 edx, DWORD PTR _readbuffer$[ebp]
  0006e	83 c2 10	 add	 edx, 16			; 00000010H
  00071	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 101  : 	_mm_storeu_ps(readbuffer + (4 * 2), xmm_read_register_2);

  00074	0f 10 45 c0	 movups	 xmm0, XMMWORD PTR _xmm_read_register_2$[ebp]
  00078	8b 45 fc	 mov	 eax, DWORD PTR _readbuffer$[ebp]
  0007b	83 c0 20	 add	 eax, 32			; 00000020H
  0007e	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 102  : 	_mm_storeu_ps(readbuffer + (4 * 3), xmm_read_register_3);

  00081	0f 10 45 b0	 movups	 xmm0, XMMWORD PTR _xmm_read_register_3$[ebp]
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _readbuffer$[ebp]
  00088	83 c1 30	 add	 ecx, 48			; 00000030H
  0008b	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 103  : 	_mm_storeu_ps(readbuffer + (4 * 4), xmm_read_register_4);

  0008e	0f 10 45 a0	 movups	 xmm0, XMMWORD PTR _xmm_read_register_4$[ebp]
  00092	8b 55 fc	 mov	 edx, DWORD PTR _readbuffer$[ebp]
  00095	83 c2 40	 add	 edx, 64			; 00000040H
  00098	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 104  : 	_mm_storeu_ps(readbuffer + (4 * 5), xmm_read_register_5);

  0009b	0f 10 45 90	 movups	 xmm0, XMMWORD PTR _xmm_read_register_5$[ebp]
  0009f	8b 45 fc	 mov	 eax, DWORD PTR _readbuffer$[ebp]
  000a2	83 c0 50	 add	 eax, 80			; 00000050H
  000a5	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 105  : 	_mm_storeu_ps(readbuffer + (4 * 6), xmm_read_register_6);

  000a8	0f 10 45 80	 movups	 xmm0, XMMWORD PTR _xmm_read_register_6$[ebp]
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _readbuffer$[ebp]
  000af	83 c1 60	 add	 ecx, 96			; 00000060H
  000b2	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 106  : 	_mm_storeu_ps(readbuffer + (4 * 7), xmm_read_register_7);

  000b5	0f 10 85 70 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _xmm_read_register_7$[ebp]
  000bc	8b 55 fc	 mov	 edx, DWORD PTR _readbuffer$[ebp]
  000bf	83 c2 70	 add	 edx, 112		; 00000070H
  000c2	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 107  : 
; 108  : 	return readbuffer;

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _readbuffer$[ebp]

; 109  : }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	8b e3		 mov	 esp, ebx
  000cd	5b		 pop	 ebx
  000ce	c3		 ret	 0
_ReadSSERegisters@0 ENDP
_TEXT	ENDS
END
